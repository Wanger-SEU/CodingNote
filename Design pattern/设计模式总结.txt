设计模式
    策略模式：
定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
每一种算法都生成一个类，然后建立一个context类，这个类根据传入的参数来决定生成哪种算法的对象，执行哪种算法的函数。
应用场景：cache替换算法 ，超市的打折 优惠券 和200减50优惠等的实现。

    装饰模式：
动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
比如手机基类有两个派生类  小米手机和iPhone子类。我们想装饰着两个子类，
就用一个装饰类 继承手机类。这个装饰类的构造函数中，传入小米手机或者iphone类。然后这个装饰类再派生出两个装饰子类：贴膜子类和加壳子类。
这两个子类中就可以通过基类来执行小米手机和iPhone类中的函数，然后在执行的时候可以增加一些自己定义的装饰功能函数。从而实现装饰。

    代理模式：
为其他对象提供一种代理以控制对这个对象的访问。
代理模式的应用：远程代理 虚拟代理 安全代理 智能引用
虚拟代理就是根据需要创建开销很大的对象，通过它来实例化需要很长时间的真是对象，
比如大的图片可以使用虚拟代理来代替真实的图片，代理存储真实图片的路径和尺寸。
安全代理就是用来控制真实对象访问时的权限。
智能引用：是指当调用真实的对象时，代理处理另外一些事，比如计算真实对象的引用次数。

    工厂方法模式：
简单工厂模式的缺点：就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：
软件实体（类、模块、函数）可以扩展，但是不可修改。
定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

    原型模式：
写简历时，我们只需手写一份，然后利用打印设备复印多份即可。如果要修改简历中的某项，那么修改原始的版本就可以了，
然后再复印。原始的那份手写稿相当于是一个原型，有了它，就可以通过复印（拷贝）创造出更多的新简历。
这就是原型模式的基本思想。

    模板方法模式：
当我们要完成在某一细节层次一致的一个过程或一些列步骤，但其个别步骤在更详细的层次上的实现可能不同时，
可以考虑使用模板方法模式来处理。
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构
即可重定义该算法的某些特定步骤。算法的骨架就是模板。

    外观模式：
比如用户投资的时候把钱交给基金公司，然后基金公司提供外观接口，用户只需要买入卖出基金就可以理财，
不用去管具体的买入股票和债券等的操作。外观模式是为复杂的子系统提供简单的接口，使耦合度降低便于用户使用。

    建造者模式：
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示时，可以使用构建者模式。
如果使用了构建者模式，那么用户就只需要知道需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。
设置一个建造指挥官的类，这个类根据传入的类型（胖人还是瘦人）来在建造函数中调用相应的流程接口来实现建造过程（画人的头 手脚等）
用户只需要生成一个指挥官的对象，然后传入相应的类型，通过这个对象来调用构建函数即可。
建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式

    观察者模式
又叫发布-订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，
会通知所有观察者对象，使他们能够自动更新自己。
当一个对象的改变需要同时改变其他对象的时候，而且它也不知道具体有多少对象有待改变时，应该考虑使用观察者模式。
观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

   抽象工厂模式、
涉及到多个产品系列的时候用抽象工厂模式。
工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
    
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
     
    状态模式
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式要解决的是当控制一个对象状态转换的条件表达式
过于复杂时的情况，把状态的判断逻辑转移到表示不同
状态的一系列类当中，可以把复杂的判断逻辑简化。
   适配器模式：
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
在适配器类中定义标准的接口，然后在这个标准的接口中调用不兼容的接口。就相当于找了一个翻译。

    备忘录模式：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
比如打游戏保存进度。

    组合模式：
需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式了。
比如一个公司的总部与分公司都有相似的结构，就可以使用组合模式。
建立一个公司类。然后有增加部门和删除部门的接口。公司总部继承这个类，财务部和人力资源部也继承这个类。
然后在客户端可以建立公司总部对象，然后调用增加部门接口增加财务部和人力资源部对象。还能增加分公司对象。
分公司对象也能增加财务部和人力资源部对象。这些都以树的形式挂载在公司总部这个根节点上。

    迭代器模式：
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

    单例模式：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

    桥接模式：
将抽象部分与它的实现部分分离，使它们都可以独立地变化。
考虑装操作系统，有多种配置的计算机，同样也有多款操作系统。如何运用桥接模式呢？
可以将操作系统和计算机分别抽象出来，让它们各自发展，减少它们的耦合度。
windows 操作系统和Linux操作系统分别继承自操作系统类。
戴尔电脑和惠普电脑分别继承自计算机类。
然后计算机类中传入操作系统对象的指针，在客户端中生成一个戴尔电脑对象。
调用这个戴尔电脑对象的装系统函数时传入Linux操作系统对象。
这个装系统函数中调用了Linux操作系统对象中的函数来打印系统信息，

    命令模式：
将一个请求封装为一个对象，从而使你可以用不同的请求对
客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
比如烤羊肉串，可以定义一个命令类，然后继承出 烤鸡翅命令类和烤羊肉命令类。
每个命令类中都绑定烤肉的厨师对象，在执行命令接口中调用厨师对象执行烤肉操作。
定义一个服务员类，可以把每次客人的命令保存到列表中，然后定义一个执行函数，负责执行命令。
命令模式第一能较容易地设计一个命令队列，第二在需要的情况下，可以较容易地将命令记入日志，
第三允许接受请求的一方决定是否要否决请求。第四可以容易地实现对请求的撤销和重做，
第五由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。最关键的是
把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

    职责链模式：
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，
并沿着这条链传递该请求，直到有一个对象处理它为止。
比如加薪的要求，如果数目小于500 经理对象就能处理，大于500就传递到总监对象，如果小于1000总监对象
能直接批准，大于1000就传递给总经理对象。
当客户提交一个请求时，请求是沿链传递直至有一个对象负责处理他的。
比如有经理 总监 总经理三个对象。每个对象初始化的时候都要设置上级，然后在处理请求的函数中，如果请求能处理则处理，
否则就调用上级的处理函数来处理。这样就实现了请求的自动传递。避免了在每一个等级中都是一堆的if else来处理请求。大量的分支判断会造成维护难、灵活性差的问题。

    中介模式：
用一个中介对象来封装一些列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
生成两个员工对象 一个中介对象。员工对象初始化时都绑定中介对象。中介对象中的通知方法的逻辑就是：
假如是a员工发的消息就调用b员工对象的通知方法 打印出消息，假如是b员工发的消息，就转给a员工对象的通知方法 打印出消息。
a员工和b员工的发送消息方法就是调用了中介对象的通知方法。

    享元模式：
运用共享技术有效地支持大量细粒度的对象。

























   
   
   
   
   
   