设计模式
    策略模式：
定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
每一种算法都生成一个类，然后建立一个context类，这个类根据传入的参数来决定生成哪种算法的对象，执行哪种算法的函数。
应用场景：cache替换算法 ，超市的打折 优惠券 和200减50优惠等的实现。

    装饰模式：
动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
比如手机基类有两个派生类  小米手机和iPhone子类。我们想装饰着两个子类，
就用一个装饰类 继承手机类。这个装饰类的构造函数中，传入小米手机或者iphone类。然后这个装饰类再派生出两个装饰子类：贴膜子类和加壳子类。
这两个子类中就可以通过基类来执行小米手机和iPhone类中的函数，然后在执行的时候可以增加一些自己定义的装饰功能函数。从而实现装饰。

    代理模式：
为其他对象提供一种代理以控制对这个对象的访问。
代理模式的应用：远程代理 虚拟代理 安全代理 智能引用
虚拟代理就是根据需要创建开销很大的对象，通过它来实例化需要很长时间的真是对象，
比如大的图片可以使用虚拟代理来代替真实的图片，代理存储真实图片的路径和尺寸。
安全代理就是用来控制真实对象访问时的权限。
智能引用：是指当调用真实的对象时，代理处理另外一些事，比如计算真实对象的引用次数。

    工厂方法模式：
简单工厂模式的缺点：就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：
软件实体（类、模块、函数）可以扩展，但是不可修改。
定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

    原型模式：
写简历时，我们只需手写一份，然后利用打印设备复印多份即可。如果要修改简历中的某项，那么修改原始的版本就可以了，
然后再复印。原始的那份手写稿相当于是一个原型，有了它，就可以通过复印（拷贝）创造出更多的新简历。
这就是原型模式的基本思想。

    模板方法模式：
当我们要完成在某一细节层次一致的一个过程或一些列步骤，但其个别步骤在更详细的层次上的实现可能不同时，
可以考虑使用模板方法模式来处理。
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构
即可重定义该算法的某些特定步骤。算法的骨架就是模板。

    外观模式：
比如用户投资的时候把钱交给基金公司，然后基金公司提供外观接口，用户只需要买入卖出基金就可以理财，
不用去管具体的买入股票和债券等的操作。外观模式是为复杂的子系统提供简单的接口，使耦合度降低便于用户使用。

    建造者模式：
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示时，可以使用构建者模式。
如果使用了构建者模式，那么用户就只需要知道需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。
设置一个建造指挥官的类，这个类根据传入的类型（胖人还是瘦人）来在建造函数中调用相应的流程接口来实现建造过程（画人的头 手脚等）
用户只需要生成一个指挥官的对象，然后传入相应的类型，通过这个对象来调用构建函数即可。
建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式

    观察者模式
又叫发布-订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，
会通知所有观察者对象，使他们能够自动更新自己。
当一个对象的改变需要同时改变其他对象的时候，而且它也不知道具体有多少对象有待改变时，应该考虑使用观察者模式。
观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

   抽象工厂模式、
涉及到多个产品系列的时候用抽象工厂模式。
工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
    
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
     
    状态模式
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式要解决的是当控制一个对象状态转换的条件表达式
过于复杂时的情况，把状态的判断逻辑转移到表示不同
状态的一系列类当中，可以把复杂的判断逻辑简化。
   适配器模式：
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
在适配器类中定义标准的接口，然后在这个标准的接口中调用不兼容的接口。就相当于找了一个翻译。

    备忘录模式：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
比如打游戏保存进度。

    组合模式：
需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式了。
比如一个公司的总部与分公司都有相似的结构，就可以使用组合模式。
建立一个公司类。然后有增加部门和删除部门的接口。公司总部继承这个类，财务部和人力资源部也继承这个类。
然后在客户端可以建立公司总部对象，然后调用增加部门接口增加财务部和人力资源部对象。还能增加分公司对象。
分公司对象也能增加财务部和人力资源部对象。这些都以树的形式挂载在公司总部这个根节点上。

    迭代器模式：
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

    单例模式：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
   
   
   
   
   
   
   